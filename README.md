# 前言

这学期的五子棋对我来说真是意义非凡，他驱动我从一个只是对c语言略知一二的几乎纯小白学会了很多东西，上网查资料，翻阅各种博客，提前预习一些数据结构，一个学期一大半空闲时间都花在了写五子棋，从最初的完全无从下手,到能够自己创新出一些优化的东西。

依稀记得我的五子棋第一次动起来会堵人那个晚上，内心激动无比，感觉我就是“c语言大佬”QAQ，不过后来发现其实都是bug，会堵人纯属意外。

我第一个月就写出了能和我这个五子棋小白对打的版本，但后续的改进陷入了瓶颈，大部分时间花在了改进时间性能，没有优化算法，最后甚至没时间研究一下VCT和VCF，棋力很一般，和几个网上找到的几个AI下都是完败，为此还是有些遗憾。

参考资料：
+ 象棋百科全书：<https://www.xqbase.com/>
+ gobang：<https://github.com/lihongxun945/gobang>
+ 清月连珠：<https://www.cnblogs.com/zcsor/p/3383090.html>
+ 《PC游戏编程(人机博弈)》 王小春

# 实现的东西

本AI采用PVS改进的alphabeta剪枝算法为主干，通过预先评估早期裁剪选出每步20个走法实现8层搜索，目前算杀有有待优化。

+ 位棋盘生成走法
+ 单行评分缓存
+ 早期裁剪
+ 哈希匹配判断禁手

# 未实现的东西

当初立下壮志，结果最后一个星期成了小阳人，加上最后也有点懒惰，一些已经有了思路的东西最终没有实现。

## **冲棋点哈希表**

在我的evaluate中预先缓存了一行最多15个棋子所有情况对应的评分，因此大大缩短了评估时间。事实上我们不仅可以缓存评分，还可以缓存对应棋盘的冲棋信息，即一行哪些点可以冲棋，是活三还是冲四，如此一来在获取走法的时候也会相当迅速，特别是在已经有活三冲四的情况下，我们很多时候只需要搜索活三冲四点进行防守或反击，在五子棋中后阶段大多都是这种情况，例如对方活三，我们能走的点只有封堵和四个以上的连子，对方连四了我们只能封堵或者成五，更精确更少的走法同时也意味着更深的深度。本程序最后只能通过分数值来区分普通走法和活三冲四走法，尽管也能用，但是不精确，也浪费了搜索，比如在对方已经活三时，再去走活三就等于送死。

这样缓存大概需要四千万个节点，充分利用好一个字节的每一位其实也就消耗几十到一百多mb，还是很够用的。

## **开局库**

已经证明即使有禁手，黑棋也是必胜的。完全可以通过开局库把开局引向一个靠我的AI能够找到VCT VCF解的局面来达到百分百胜率，我在网上也找到了一些开局的必胜谱，但是我不知道怎么解析这些lib文件，貌似是什么静态库，虽然通过Renlib软件打开可以看谱，但是总不能纯靠手打录入这些信息吧，最后还是放弃了。

## **威胁空间搜索**

最初在<https://www.cnblogs.com/zcsor>这位博主的一篇文章了解到这个东西，原文应该是Go-Moku and Threat-Space Search，作者：LV Allis，H.J. Van Den Herik，MPH Huntjens，不过国内某十多年前的五子棋论文里面有雷同的中文版，大概也就是阐述了VCT和VCF的理论化，给出了一个找致胜威胁的具体方法。然而具体过程还是略显复杂，最后算杀还是只是搜索分数足够大的点下棋。

# 一些被弃用的东西



## **空着裁剪**

参考<https://www.xqbase.com/computer/advanced_nullmove.htm>，其实就是一步不下棋，然后给对方下，最后返回值仍然好到超过我们设置的beta值，说明正常下那肯定也会超过beta，那就直接返回beta。某个版本我实现了一点简单的空着裁剪，但是总感觉怪怪的，并且出现了一些bug，最后放弃了。

## **zobrist置换表**

因为刚开始没有接触哈希表这种东西，一直想不通怎么才能实现这个置换表，为此那一周的日思夜想，查了好多资料终于实现以后却发现效果非常一般，占了好几百兆也就快了20%左右，后来因为我的评分方式改为每下一步刷新，那这个存储整个局面分的置换表感觉就不太有用了，但是这种哈希表缓存的思想特别有用。

## **历史表排序**

alpha-beta搜索里顺序特别重要，因此可以通过迭代加深获取浅层节点的历史评分对节点进行排序，为每层搜索的最好节点和beta截断节点设置一个历史分，根据历史分排序显著提高速度，实现简单效果立竿见影。不过为了早期剪枝，同时有了评分哈希表，就放弃了这种排序，直接通过评分排序。

## **MTD(f)搜索算法**

mtd(f)和pvs都是alphabeta剪枝的优化算法，只需要加几行就可以带来一定的速度优化，不过mtd(f)要略复杂一点，并且非常依赖于每次搜索的评分期望值，据说MTD(f)是优于PVS，但是本人实测mtd(f)非常不稳定，据说mtd(f)在并行计算上有优势，奈何本人水平太次，完全看不懂c语言并行计算的部分，还没有线程之类的概念。